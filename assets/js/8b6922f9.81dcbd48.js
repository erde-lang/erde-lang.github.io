"use strict";(self.webpackChunkerde_lang_github_io=self.webpackChunkerde_lang_github_io||[]).push([[3019],{3905:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return g}});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(t),g=r,m=d["".concat(s,".").concat(g)]||d[g]||u[g]||o;return t?a.createElement(m,i(i({ref:n},p),{},{components:t})):a.createElement(m,i({ref:n},p))}));function g(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},95212:function(e,n,t){t.r(n),t.d(n,{assets:function(){return p},contentTitle:function(){return s},default:function(){return g},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return u}});var a=t(87462),r=t(63366),o=(t(67294),t(3905)),i=["components"],l={sidebar_position:2,sidebar_label:"Breaking Changes w/ Lua"},s="Breaking Changes w/ Lua",c={unversionedId:"breaking-changes-lua",id:"breaking-changes-lua",title:"Breaking Changes w/ Lua",description:"While Erde attempts to keep most core behaviors consistent w/ Lua, there are a",source:"@site/src/docs/breaking-changes-lua.md",sourceDirName:".",slug:"/breaking-changes-lua",permalink:"/docs/breaking-changes-lua",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,sidebar_label:"Breaking Changes w/ Lua"},sidebar:"sidebar",previous:{title:"Getting Started",permalink:"/docs/"},next:{title:"Reference",permalink:"/docs/reference"}},p={},u=[{value:"Neq Operator: <code>~=</code> vs <code>!=</code>",id:"neq-operator--vs-",level:2},{value:"Local Functions by Default",id:"local-functions-by-default",level:2},{value:"Spreading Varargs",id:"spreading-varargs",level:2}],d={toc:u};function g(e){var n=e.components,t=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"breaking-changes-w-lua"},"Breaking Changes w/ Lua"),(0,o.kt)("p",null,"While Erde attempts to keep most core behaviors consistent w/ Lua, there are a\ncouple of necessary breaking changes."),(0,o.kt)("h2",{id:"neq-operator--vs-"},"Neq Operator: ",(0,o.kt)("inlineCode",{parentName:"h2"},"~=")," vs ",(0,o.kt)("inlineCode",{parentName:"h2"},"!=")),(0,o.kt)("p",null,"In Erde, the neq operator uses ",(0,o.kt)("inlineCode",{parentName:"p"},"!=")," instead of Lua's ",(0,o.kt)("inlineCode",{parentName:"p"},"~="),". This is mainly\nbecause Erde keeps ",(0,o.kt)("a",{parentName:"p",href:"https://www.lua.org/manual/5.3/manual.html#3.4.2"},"Lua's bit operators"),"\nand allows for operator assignments w/ these operators. This means that ",(0,o.kt)("inlineCode",{parentName:"p"},"~=")," is\nalready taken by the bitwise exclusive OR operator assignment. For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-erde"},"local x = 0b101\nx ~= 0b011\nprint(x) -- 0b110\n")),(0,o.kt)("p",null,"Initially, since bitwise operators are hardly used by most programmers, bitwise\noperators were actually prefixed with ",(0,o.kt)("inlineCode",{parentName:"p"},".")," in order to preserve the ",(0,o.kt)("inlineCode",{parentName:"p"},"~=")," operator.\nThus, the above would have been:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-erde"},"local x = 0b101\nx .~= 0b011\nprint(x) -- 0b110\n")),(0,o.kt)("p",null,"However, as the majority of bitwise operators are consistent across the majority\nof programming languages, combined w/ the fact that almost all other languages\nuse ",(0,o.kt)("inlineCode",{parentName:"p"},"!="),", I decided it would be best to simply use ",(0,o.kt)("inlineCode",{parentName:"p"},"!=")," for the neq operator."),(0,o.kt)("h2",{id:"local-functions-by-default"},"Local Functions by Default"),(0,o.kt)("p",null,"In Lua, everything is global by default. Since the function syntax in Lua is\nsimply syntactic sugar for assigning an anonymous function to a label, this means\nthat the following creates a global function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"function myFunction()\n  print('hello world')\nend\n")),(0,o.kt)("p",null,"This is an ",(0,o.kt)("strong",{parentName:"p"},"extremely")," common mistake in Lua, especially to those newer to the\nlanguage (I ",(0,o.kt)("em",{parentName:"p"},"still")," forget this occasionally). To accomodate for this, functions\nin Erde are by default local. Thus the following are equivalent:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"local function myFunction()\n  print('hello world')\nend\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-erde"},"function myFunction() {\n  print('hello world')\n}\n")),(0,o.kt)("p",null,"This is ",(0,o.kt)("strong",{parentName:"p"},"not")," true for labels. All declarations should have a scope keyword,\nas it makes code much easier to read (one can easily spot when a variable is\ndeclared). For functions, this is repetitive, as its obvious where a function is\ndeclared."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-erde"},"-- Bad, this will create a global!\nmyFunction = () -> print('hello world')\n")),(0,o.kt)("h2",{id:"spreading-varargs"},"Spreading Varargs"),(0,o.kt)("p",null,"In Lua, spreading varargs has inconsistent behavior depending on the position\nof the varargs. Consider the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"function leadingVarargs(...)\n  print({ ..., 'last' })\nend\n\nfunction trailingVarargs(...)\n  print({ 'first', ... })\nend\n\nleadingVarargs('a', 'b') -- a last\ntrailingVarargs('a', 'b') -- first a b\n")),(0,o.kt)("p",null,"Varargs get spread completely when appearing last in a list, and otherwise only\nreturn the first element (this is true for both table declarations and function\nparameters)."),(0,o.kt)("p",null,"In Erde, spreading varargs behave exactly like the spread operator. That is, the\nvarargs are spread completely regardless of their position:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-erde"},"function leadingVarargs(...) {\n  print({ ..., 'last' })\n}\n\nfunction trailingVarargs(...) {\n  print({ 'first', ... })\n}\n\nleadingVarargs('a', 'b') -- a b last\ntrailingVarargs('a', 'b') -- first a b\n")))}g.isMDXComponent=!0}}]);