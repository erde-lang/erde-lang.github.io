"use strict";(self.webpackChunkerde_lang_github_io=self.webpackChunkerde_lang_github_io||[]).push([[138],{83626:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return o},contentTitle:function(){return p},metadata:function(){return s},toc:function(){return d},default:function(){return m}});var n=a(87462),r=a(63366),l=(a(67294),a(3905)),i=["components"],o={title:"",sidebar_label:"Reference (for Lua users)"},p=void 0,s={unversionedId:"reference-lua",id:"reference-lua",isDocsHomePage:!1,title:"",description:"Comments",source:"@site/src/docs/reference-lua.md",sourceDirName:".",slug:"/reference-lua",permalink:"/docs/reference-lua",tags:[],version:"current",frontMatter:{title:"",sidebar_label:"Reference (for Lua users)"},sidebar:"sidebar",previous:{title:"Introduction",permalink:"/docs/"}},d=[{value:"Comments",id:"comments",children:[],level:2},{value:"Numbers",id:"numbers",children:[],level:2},{value:"Strings",id:"strings",children:[],level:2},{value:"Tables",id:"tables",children:[],level:2},{value:"Variables / Scope",id:"variables--scope",children:[{value:"global",id:"global",children:[],level:3},{value:"module",id:"module",children:[],level:3}],level:2},{value:"Operators",id:"operators",children:[{value:"Arithmetic Operators",id:"arithmetic-operators",children:[],level:3},{value:"Relational Operators",id:"relational-operators",children:[],level:3},{value:"Logical Operators",id:"logical-operators",children:[],level:3},{value:"Bitwise Operators",id:"bitwise-operators",children:[],level:3},{value:"Concatenation / Length Operators",id:"concatenation--length-operators",children:[],level:3},{value:"Ternary Operator",id:"ternary-operator",children:[],level:3},{value:"Null Coalascing Operator",id:"null-coalascing-operator",children:[],level:3},{value:"Pipe Operator",id:"pipe-operator",children:[],level:3},{value:"Assignment Operators",id:"assignment-operators",children:[],level:3}],level:2},{value:"Logic Constructs",id:"logic-constructs",children:[{value:"do",id:"do",children:[],level:3},{value:"if else",id:"if-else",children:[],level:3},{value:"for",id:"for",children:[],level:3},{value:"while",id:"while",children:[],level:3},{value:"repeat ... until",id:"repeat--until",children:[],level:3}],level:2},{value:"Optional Chaining",id:"optional-chaining",children:[],level:2},{value:"Destructuring",id:"destructuring",children:[],level:2},{value:"Functions",id:"functions",children:[{value:"Parameters",id:"parameters",children:[],level:3},{value:"Arrow Functions",id:"arrow-functions",children:[],level:3}],level:2}],u={toc:d};function m(e){var t=e.components,a=(0,r.Z)(e,i);return(0,l.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"comments"},"Comments"),(0,l.kt)("p",null,"Unchanged from Lua."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde"},"-- this is a single line comment\n--[[\n  this is a\n  multiline comment\n]]\n")),(0,l.kt)("h2",{id:"numbers"},"Numbers"),(0,l.kt)("p",null,"Unchanged from Lua."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde"},"print(43)\nprint(1.9e1)\nprint(0xfp+2)\n")),(0,l.kt)("h2",{id:"strings"},"Strings"),(0,l.kt)("p",null,"String are ",(0,l.kt)("em",{parentName:"p"},"mostly")," unchanged from Lua. Erde additionally allows for\ninterpolation in any string form using braces. Braces may be escaped to be used\nliterally. Escaping the end brace is optional."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde"},"local msg = 'world'\n\nlocal singleQuotes = 'hello {msg}'\nlocal doubleQuotes = \"hello {msg}\"\nlocal multiline = [[hello {msg}]]\n\n-- equivalent\nlocal braceLiteral1 = '\\{ 1, 2 \\}'\nlocal braceLiteral2 = '\\{ 1, 2 }'\n")),(0,l.kt)("h2",{id:"tables"},"Tables"),(0,l.kt)("p",null,"Unchanged from Lua. This includes 1-based indexing."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde"},"local t = {\n  -- key value pairs\n  hello = 'world',\n  goodbye = 'society',\n  ['id:{myid}'] = 'test',\n\n  -- ipairs values\n  42,\n  'i am a string at index 2',\n}\n")),(0,l.kt)("h2",{id:"variables--scope"},"Variables / Scope"),(0,l.kt)("p",null,"Variable declarations are completely backwards compatible with Lua. However,\nthe ",(0,l.kt)("inlineCode",{parentName:"p"},"global")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"module")," scope keywords also have been added."),(0,l.kt)("h3",{id:"global"},"global"),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"global")," keyword is an ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("em",{parentName:"strong"},"optional"))," keyword for declaring global\nvariables. It may only occur at the top level of a module."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde"},"-- Good\nglobal MY_GLOBAL = 1\n\nif math.random(1, 10) > 5 {\n  -- Bad\n  global MY_GLOBAL = 1\n}\n")),(0,l.kt)("p",null,"The reason the ",(0,l.kt)("inlineCode",{parentName:"p"},"global"),' keyword is optional is that the parser cannot know the\nenvironment the script will be run in. While we could provide "hints" to the\ncompiler about a scripts environment, this is a lot of overhead that could prove\nmore obnoxious than helpful. In the future, this may be an opt-in feature.'),(0,l.kt)("h3",{id:"module"},"module"),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"module")," keyword acts as an ",(0,l.kt)("inlineCode",{parentName:"p"},"export")," statement. All variables with the\n",(0,l.kt)("inlineCode",{parentName:"p"},"module")," scope will be placed into a table, which is then returned at the end of\nthe script. Like the ",(0,l.kt)("inlineCode",{parentName:"p"},"global")," keyword, it may only occur at the top level of a\nmodule and may not be used in conjunction with ",(0,l.kt)("inlineCode",{parentName:"p"},"return"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde",metastring:'title="foo.lua"',title:'"foo.lua"'},"module function echo(msg) {\n  print(msg)\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde",metastring:'title="bar.lua"',title:'"bar.lua"'},"local foo = require('foo')\nfoo.echo('hello world')\n")),(0,l.kt)("p",null,"Note that this keyword conflicts with the built-in ",(0,l.kt)("inlineCode",{parentName:"p"},"module")," function in Lua 5.1,\nwhich means that the ",(0,l.kt)("inlineCode",{parentName:"p"},"module")," function is not usable in Erde (although the use\nof Lua's ",(0,l.kt)("inlineCode",{parentName:"p"},"module")," function is ",(0,l.kt)("a",{parentName:"p",href:"http://lua-users.org/wiki/LuaModuleFunctionCritiqued"},"highly discouraged"),"\nanyways)."),(0,l.kt)("h2",{id:"operators"},"Operators"),(0,l.kt)("h3",{id:"arithmetic-operators"},"Arithmetic Operators"),(0,l.kt)("p",null,"Unchanged from Lua."),(0,l.kt)("center",null,(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Syntax"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Operator"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Example"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"+"),(0,l.kt)("td",{parentName:"tr",align:"left"},"addition"),(0,l.kt)("td",{parentName:"tr",align:"left"},"1 + 2 == 3")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"-"),(0,l.kt)("td",{parentName:"tr",align:"left"},"subtraction"),(0,l.kt)("td",{parentName:"tr",align:"left"},"1 - 2 == -1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"-"),(0,l.kt)("td",{parentName:"tr",align:"left"},"unary minus"),(0,l.kt)("td",{parentName:"tr",align:"left"},"-4")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"*"),(0,l.kt)("td",{parentName:"tr",align:"left"},"multiplication"),(0,l.kt)("td",{parentName:"tr",align:"left"},"2 ","*"," 4 == 8")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"/"),(0,l.kt)("td",{parentName:"tr",align:"left"},"division"),(0,l.kt)("td",{parentName:"tr",align:"left"},"10 / 2 == 5")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"//"),(0,l.kt)("td",{parentName:"tr",align:"left"},"floor division"),(0,l.kt)("td",{parentName:"tr",align:"left"},"10 // 4 == 2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"^"),(0,l.kt)("td",{parentName:"tr",align:"left"},"exponentiation"),(0,l.kt)("td",{parentName:"tr",align:"left"},"2 ^ 6 == 64")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"%"),(0,l.kt)("td",{parentName:"tr",align:"left"},"modulo"),(0,l.kt)("td",{parentName:"tr",align:"left"},"6 % 2 == 0"))))),(0,l.kt)("h3",{id:"relational-operators"},"Relational Operators"),(0,l.kt)("p",null,"Unchanged from Lua."),(0,l.kt)("center",null,(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Syntax"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Operator"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Example"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"=="),(0,l.kt)("td",{parentName:"tr",align:"left"},"equality"),(0,l.kt)("td",{parentName:"tr",align:"left"},"1 + 1 == 2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"~="),(0,l.kt)("td",{parentName:"tr",align:"left"},"inequality"),(0,l.kt)("td",{parentName:"tr",align:"left"},"1 + 1 ~= 3")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"<"),(0,l.kt)("td",{parentName:"tr",align:"left"},"less than"),(0,l.kt)("td",{parentName:"tr",align:"left"},"3 < 5")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},">"),(0,l.kt)("td",{parentName:"tr",align:"left"},"greater than"),(0,l.kt)("td",{parentName:"tr",align:"left"},"9 > 7")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"<="),(0,l.kt)("td",{parentName:"tr",align:"left"},"less or equal"),(0,l.kt)("td",{parentName:"tr",align:"left"},"9 >= 8, 9 >= 9")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},">="),(0,l.kt)("td",{parentName:"tr",align:"left"},"greater or equal"),(0,l.kt)("td",{parentName:"tr",align:"left"},"9 <= 11, 11 <= 11"))))),(0,l.kt)("h3",{id:"logical-operators"},"Logical Operators"),(0,l.kt)("center",null,(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Syntax"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Operator"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Example"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"|"),(0,l.kt)("td",{parentName:"tr",align:"left"},"or"),(0,l.kt)("td",{parentName:"tr",align:"left"},"true ","|"," false == true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"&"),(0,l.kt)("td",{parentName:"tr",align:"left"},"and"),(0,l.kt)("td",{parentName:"tr",align:"left"},"true & false == false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"~"),(0,l.kt)("td",{parentName:"tr",align:"left"},"unary NOT"),(0,l.kt)("td",{parentName:"tr",align:"left"},"~false == true"))))),(0,l.kt)("br",null),(0,l.kt)("p",null,"The unary logical NOT operator uses the ",(0,l.kt)("inlineCode",{parentName:"p"},"~")," token in order to maintain\nconsistency with inequality (",(0,l.kt)("inlineCode",{parentName:"p"},"~="),"). The ",(0,l.kt)("inlineCode",{parentName:"p"},"!")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"!=")," tokens were intentionally\navoided as it would surely cause divides among developers on which to use. It\nalso leaves the ",(0,l.kt)("inlineCode",{parentName:"p"},"!")," token available for use in the future."),(0,l.kt)("h3",{id:"bitwise-operators"},"Bitwise Operators"),(0,l.kt)("p",null,"Erde supports bitwise operators, but unlike most languages repurposes the\nsyntax. ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("em",{parentName:"strong"},"Traditional bitwise operators must be prefixed with ",(0,l.kt)("inlineCode",{parentName:"em"},"."),"."))),(0,l.kt)("center",null,(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Syntax"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Operator"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Example"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},".","|"),(0,l.kt)("td",{parentName:"tr",align:"left"},"or"),(0,l.kt)("td",{parentName:"tr",align:"left"},"0b100 .","|"," 0b010 == 0b110")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},".&"),(0,l.kt)("td",{parentName:"tr",align:"left"},"and"),(0,l.kt)("td",{parentName:"tr",align:"left"},"0b110 .& 0b101 == 0b100")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},".~"),(0,l.kt)("td",{parentName:"tr",align:"left"},"xor"),(0,l.kt)("td",{parentName:"tr",align:"left"},"0b110 .~ 0b101 == 0b011")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},".~"),(0,l.kt)("td",{parentName:"tr",align:"left"},"unary NOT"),(0,l.kt)("td",{parentName:"tr",align:"left"},".~0b100 == 0b011")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},".>>"),(0,l.kt)("td",{parentName:"tr",align:"left"},"right shift"),(0,l.kt)("td",{parentName:"tr",align:"left"},"0b010 .>> 1 == 0b001")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},".<<"),(0,l.kt)("td",{parentName:"tr",align:"left"},"left shift"),(0,l.kt)("td",{parentName:"tr",align:"left"},"0b010 .<< 1 == 0b100"))))),(0,l.kt)("br",null),(0,l.kt)("p",null,"The reason for the unconventional syntax is that Erde uses the ",(0,l.kt)("inlineCode",{parentName:"p"},"~")," symbol as the\nunary logical NOT to remain consistent with ",(0,l.kt)("inlineCode",{parentName:"p"},"~="),", which conflicts with Lua5.3+'s\nunary bitwise NOT and bitwise exclusive OR. The traditional bitop symbols also\nconsume some of the most convenient syntax tokens while being seldom used by\nthe average developer. Prefixing traditional bitwise operators with ",(0,l.kt)("inlineCode",{parentName:"p"},".")," frees\nthese tokens for other uses, such as using ",(0,l.kt)("inlineCode",{parentName:"p"},"&")," for logical AND (instead of the\nmore awkward ",(0,l.kt)("inlineCode",{parentName:"p"},"&&"),") and ",(0,l.kt)("inlineCode",{parentName:"p"},">>")," for the ",(0,l.kt)("a",{parentName:"p",href:"#pipe-operator"},"Pipe Operator"),"."),(0,l.kt)("p",null,"When compiling to Lua 5.1 or 5.2, Erde will assume the target platform has\naccess to the ",(0,l.kt)("a",{parentName:"p",href:"http://bitop.luajit.org"},"BitOp")," module and bit operations will\ncompile down to ",(0,l.kt)("inlineCode",{parentName:"p"},"require('bit').xxx()")," calls."),(0,l.kt)("h3",{id:"concatenation--length-operators"},"Concatenation / Length Operators"),(0,l.kt)("p",null,"Unchanged from Lua."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde"},'print("hello" .. "world") -- helloworld\nprint(#"hello") -- 5\n')),(0,l.kt)("h3",{id:"ternary-operator"},"Ternary Operator"),(0,l.kt)("p",null,"The ",(0,l.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Ternary_operation"},"ternary operator")," is fully\nsupported in Erde. It was added to avoid the more awkward ",(0,l.kt)("inlineCode",{parentName:"p"},"a and b or c")," syntax\n(which is NOT compatible with the ternary operator in the case ",(0,l.kt)("inlineCode",{parentName:"p"},"b")," is false)."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde"},"local x = myCondition ? trueExpr : falseExpr\n")),(0,l.kt)("h3",{id:"null-coalascing-operator"},"Null Coalascing Operator"),(0,l.kt)("p",null,"The ",(0,l.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Null_coalescing_operator"},"null coalescing operator"),"\nis fully supported in Erde using ",(0,l.kt)("inlineCode",{parentName:"p"},"??"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde"},"local x = myValue ?? defaultValue\n")),(0,l.kt)("h3",{id:"pipe-operator"},"Pipe Operator"),(0,l.kt)("p",null,"The pipe operator forwards expressions into the arguments of\na function call. The initial values may be given as a single expression or as\na list of expressions surrounded by parentheses. The right hand side of the pipe\noperator ",(0,l.kt)("strong",{parentName:"p"},"must")," be a function call."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde"}," -- hello world\n'hello world' >> print()\n\n-- hello\n-- world\n('hello', 'world') >> print()\n")),(0,l.kt)("p",null,"They may be chained together, passing the returns of one function into the\narguments of another."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde"},"function add(a, b) {\n  return a + b\n}\n\n(1, 2) >> add() >> add(3) >> print() -- 6\n")),(0,l.kt)("h3",{id:"assignment-operators"},"Assignment Operators"),(0,l.kt)("p",null,"All binary operators support assignment operator shorthands. This includes the\n",(0,l.kt)("a",{parentName:"p",href:"#null-coalascing-operator"},"null coalescing")," operator"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde"},"local x = 4\nx += 6\nx /= 2\nprint(x) -- 5\n")),(0,l.kt)("h2",{id:"logic-constructs"},"Logic Constructs"),(0,l.kt)("p",null,"All logic constructs in Lua (",(0,l.kt)("inlineCode",{parentName:"p"},"do"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"if...else"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"for"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"while"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"repeat...until"),")\nare the same in Erde, with the exception of using braces instead of ",(0,l.kt)("inlineCode",{parentName:"p"},"end"),"."),(0,l.kt)("h3",{id:"do"},"do"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde"},"do {\n  ...\n}\n")),(0,l.kt)("h3",{id:"if-else"},"if else"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde"},"if n > 0 {\n  ...\n} elseif n < 0 {\n  ...\n} else {\n  ...\n}\n")),(0,l.kt)("h3",{id:"for"},"for"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde"},"for i = 1, 10, 1 {\n  ...\n}\n\nfor i, v in ipairs({ 1, 2, 3 }) {\n  ...\n}\n")),(0,l.kt)("h3",{id:"while"},"while"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde"},"while true {\n  ...\n}\n")),(0,l.kt)("h3",{id:"repeat--until"},"repeat ... until"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde"},"repeat {\n  ...\n} until true\n")),(0,l.kt)("h2",{id:"optional-chaining"},"Optional Chaining"),(0,l.kt)("p",null,"Erde allow for ",(0,l.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining"},"optional chaining"),",\nalthough with some slightly different semantics than JavaScript:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde"},"print(parent?.name)\nprint(parent.children?[1])\nparent.children?[1].scream?('i need food')\n")),(0,l.kt)("p",null,"Contrary to JavaScript (which always requires ",(0,l.kt)("inlineCode",{parentName:"p"},"?."),"), here we only need ",(0,l.kt)("inlineCode",{parentName:"p"},"?"),"\nbefore each index. As shown above, this also works for function calls."),(0,l.kt)("p",null,"You can also use optional chaining during assignment. In this case, the\nassignment will simply not occur if the chain ends early:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde"},"local parent = {}\n-- no children, doesn't do anything\nparent.children?[1].name = 'big complainer'\n")),(0,l.kt)("h2",{id:"destructuring"},"Destructuring"),(0,l.kt)("p",null,"Erde tables support ",(0,l.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment"},"destructuring"),".\nDestructuring key-value pairs uses the form ",(0,l.kt)("inlineCode",{parentName:"p"},":xxx")," (note the preceeding ",(0,l.kt)("inlineCode",{parentName:"p"},":"),")\nto distinguish itself from array destructuring:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde"},"local parent = {\n  name: 'bsuth',\n  'child1',\n  'child2',\n}\n\nlocal { :name } = parent\nlocal { firstkid, secondkid } = parent\nprint(name, firstkid, secondkid) -- bsuth child1 child2\n\n-- or all in one line\nlocal { :name, firstkid, secondkid } = parent\n")),(0,l.kt)("p",null,"Nested destructuring is also supported, where the higher level index appears\nfirst, followed by it's destructure. Note that they are separated by a space.\nIn this case, ",(0,l.kt)("em",{parentName:"p"},"only the deepest variables are kept in scope"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde"},"local { :children { child1, child2 } } = parent\nprint(children) -- nil\nprint(child1) -- child\nprint(child2) -- child\n")),(0,l.kt)("p",null,"All destructured values can be assigned defaults. Note that this is also true\nfor nested destructures:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde"},"local { :children = {} } = parent\nlocal { :children { child1 = 'mychild' } = {} } = parent\nprint(child1) -- mychild\n")),(0,l.kt)("p",null,"Note that nested destructuring will throw an ",(0,l.kt)("inlineCode",{parentName:"p"},"attempt to index a nil value"),"\nerror if the key does not exist. While we can simply assign defaults everywhere,\nthis can get pretty messy. Here, erde reuses the optional operator to allow\nan early exit of nested destructures. In this case the destructured variables\nwill simply be ",(0,l.kt)("inlineCode",{parentName:"p"},"nil"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde"},"local parent = {}\nlocal { :children? { child1 } } = parent\nprint(child1) -- nil\n")),(0,l.kt)("h2",{id:"functions"},"Functions"),(0,l.kt)("p",null,"Named functions are the same as Lua, but use braces instead of ",(0,l.kt)("inlineCode",{parentName:"p"},"end"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde"},"local function sum(a, b) {\n  return a + b\n}\n")),(0,l.kt)("p",null,"However, anonymous functions do NOT use the ",(0,l.kt)("inlineCode",{parentName:"p"},"function() ... end")," syntax.\nInstead, erde opts for arrow functions:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde"},"local greet = (name) -> {\n  print(`hello {name}!`)\n}\n")),(0,l.kt)("h3",{id:"parameters"},"Parameters"),(0,l.kt)("p",null,"Erde has support for optional parameters are varargs. Optional parameters are\nassigned a default value when nil and must come after non-optional parameters\nin the arguments list. Varargs must appear as the last parameter and may by\noptionally named:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde"},"local greet = (prefix, suffix = '!', ...names) -> {\n  print(prefix)\n  for _, name in ipairs(name) {\n    print(name)\n  }\n  print(suffix)\n}\n\ngreet('hello') -- hello!\ngreet('hello', nil, 'world') -- hello world!\ngreet('hello', '...', 'a', 'b') -- hello a b ...\n")),(0,l.kt)("p",null,"Table parameters may also be ",(0,l.kt)("a",{parentName:"p",href:"#destructuring"},"destructured"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde"},"local greetperson = ({ :name }) -> {\n  print('hello {name}!')\n}\n\ngreetperson({ name = 'world' })\n")),(0,l.kt)("h3",{id:"arrow-functions"},"Arrow Functions"),(0,l.kt)("p",null,"Like lua, erde provides a shorthand for declaring functions that take self as\nthe first parameter. In this case, the skinny arrow (",(0,l.kt)("inlineCode",{parentName:"p"},"->"),") is replaced with a\nfat one (",(0,l.kt)("inlineCode",{parentName:"p"},"=>"),"):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde"},"local Person = { name = 'bsuth' }\n\nPerson.introduce = () => {\n  print(`Hi, my name is {self.name}`)\n}\n")),(0,l.kt)("p",null,"Functions may specify an expression instead of a function body. In this case,\nthe expression becomes the return value:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde"},"// these are equivalent\n\nlocal add = (x, y) -> x + y\n\nlocal add = (x, y) -> {\n  return x + y\n}\n")),(0,l.kt)("p",null,"If there is only one argument, then you may omit the parentheses. Note that this\ndoes ",(0,l.kt)("em",{parentName:"p"},"not")," work for optional parameters or varargs, but does work for\ndestructuring:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erde"},"local echo = name -> print(name)\nlocal greet = { :name } -> print('hello {name}!')\n")))}m.isMDXComponent=!0}}]);